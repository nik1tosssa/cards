# Структура проекта "Соотнеси карточки"

## Обзор
Проект разложен на модули для лучшей организации кода, переиспользования и тестирования.

## Структура файлов

```
НПК/
├── index_new.html          # Главный HTML файл (новая версия с модулями)
├── styles.css              # Единый файл со всеми стилями
├── js/
│   ├── gameState.js        # Управление состоянием игры
│   ├── timer.js            # Логика таймера
│   ├── cardManager.js      # Создание и управление карточками
│   ├── dragDropHandler.js  # Обработка перетаскивания
│   ├── gameUI.js           # UI элементы и модальные окна
│   ├── fileLoader.js       # Загрузка и валидация JSON файлов
│   └── game.js             # Главный контроллер игры
└── README.md               # Этот файл
```

## Описание модулей

### 1. **gameState.js**
Управление состоянием игры.
- `GameState` объект содержит:
  - Данные карточек
  - Счетчик совпадений
  - Счетчик ошибок
  - ID перетаскиваемой карточки
  - Методы для изменения состояния

### 2. **timer.js**
Управление таймером.
- `GameTimer` объект:
  - Запуск/остановка таймера
  - Форматирование времени (mm:ss)
  - Получение прошедшего времени

### 3. **cardManager.js**
Управление карточками DOM.
- `CardManager` объект:
  - Создание элементов карточек
  - Перемешивание массивов (Fisher-Yates алгоритм)
  - Разделение концепций и определений
  - Рендеринг карточек на поле
  - Маркировка совпавших карточек

### 4. **dragDropHandler.js**
Обработка операций перетаскивания.
- `DragDropHandler` объект:
  - `handleDragStart` - начало перетаскивания
  - `handleDragOver` - над целью
  - `handleDragEnter` - вход в зону
  - `handleDragLeave` - выход из зоны
  - `handleDrop` - сброс карточки
  - `handleSuccessfulMatch` - успешное сопоставление
  - `handleMismatch` - ошибка сопоставления

### 5. **gameUI.js**
Управление интерфейсом.
- `UIManager` объект:
  - Кэширование DOM элементов
  - Обновление счета и счетчика ошибок
  - Показ/скрытие модальных окон
  - Отображение сообщений о загрузке
  - Сброс UI к начальному состоянию

### 6. **fileLoader.js**
Загрузка и валидация JSON файлов.
- `FileLoader` объект:
  - Обработка загрузки файла
  - Парсинг JSON
  - Валидация структуры данных
  - Обработка ошибок

### 7. **game.js**
Главный контроллер игры.
- `GameController` объект:
  - `startGame()` - запуск/перезапуск игры
  - `init()` - инициализация при загрузке страницы
  - Связь всех модулей вместе

## Поток данных

```
1. Загрузка страницы (window.load)
   ↓
2. GameController.init()
   ├─ UIManager.init() - инициализация DOM ссылок
   └─ GameController.startGame() - первый запуск
   
3. Во время игры:
   ├─ Пользователь перетаскивает карточку
   ├─ DragDropHandler перехватывает события
   ├─ GameState обновляется
   ├─ UIManager обновляет интерфейс
   └─ GameTimer отслеживает время
   
4. Окончание игры:
   ├─ Проверка GameState.isAllMatched() или GameState.isMaxErrorsReached()
   ├─ GameTimer.stop()
   └─ UIManager.showGameStatusModal()
```

## Использование пользовательского JSON

Формат JSON файла:
```json
[
  { "id": 1, "type": "concept", "content": "HTML", "matchId": 2 },
  { "id": 2, "type": "definition", "content": "Язык разметки...", "matchId": 1 },
  { "id": 3, "type": "concept", "content": "CSS", "matchId": 4 },
  { "id": 4, "type": "definition", "content": "Описывает стиль...", "matchId": 3 }
]
```

**Требования:**
- Массив четной длины
- Каждый элемент имеет: `id`, `type`, `content`, `matchId`
- `type` - "concept" или "definition"
- `matchId` - ID карточки, с которой должно совпасть

## Возможности расширения

Благодаря модульной структуре легко можно:
- Добавить новые типы карточек
- Реализовать сохранение результатов
- Добавить уровни сложности
- Интегрировать API для загрузки данных
- Добавить звуковые эффекты
- Создать мультиплеер

## Миграция

Чтобы использовать новую версию:
1. Замените `index.html` на `index_new.html` (или переименуйте обратно)
2. Создайте директорию `js/` со всеми модулями
3. Убедитесь, что `styles.css` находится в корне проекта
4. Все остальное работает автоматически

## Отличия новой версии

✅ Модульная архитектура
✅ Легче тестировать отдельные компоненты
✅ Лучше организованный код
✅ Легче добавлять новые функции
✅ Уменьшен размер основного файла
✅ Повышена переиспользуемость кода
